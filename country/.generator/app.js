const fs = require("fs");
const path = require("path");
const https = require("https");
const transliterate = require("transliteration");
const yaml = require("yaml");

const COUNTRY_SOURCE_URL =
    "https://salsa.debian.org/iso-codes-team/iso-codes/-/raw/main/data/iso_3166-1.json";
const SUBDIVISION_SOURCE_URL =
    "https://salsa.debian.org/iso-codes-team/iso-codes/-/raw/main/data/iso_3166-2.json";

function log(msg) {
    process.stderr.write("[gen] " + msg + "\n");
}

function fetchJSON(url) {
    return new Promise((resolve, reject) => {
        https.get(url, { headers: { "User-Agent": "iso-3166-scrapper" } }, (res) => {
            if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                return fetchJSON(res.headers.location).then(resolve, reject);
            }
            if (res.statusCode !== 200) {
                return reject(new Error("HTTP " + res.statusCode + " from " + url));
            }
            let data = "";
            res.on("data", (chunk) => (data += chunk));
            res.on("end", () => resolve(JSON.parse(data)));
            res.on("error", reject);
        }).on("error", reject);
    });
}

function generateCountry(rawCodes) {
    log("Processing " + rawCodes.length + " countries...");

    let codes = rawCodes.map((code) => {
        let result = {};
        result.a2 = {
            key: `Alpha2${code.alpha_2}`,
            value: code.alpha_2,
        };

        result.a3 = {
            key: `Alpha3${code.alpha_3}`,
            value: code.alpha_3,
        };

        result.name = { value: code.name };

        let enumCountryKey = code.name;

        // Custom short names for Debian iso-codes long/inverted names
        const shortNames = {
            "Bolivia, Plurinational State of": "Bolivia",
            "Bonaire, Sint Eustatius and Saba": "Bonaire",
            "British Indian Ocean Territory": "BritishIndianOcean",
            "Cocos (Keeling) Islands": "Cocos Islands",
            "Congo, The Democratic Republic of the": "DR Congo",
            "Falkland Islands (Malvinas)": "Falkland Islands",
            "French Southern Territories": "FrenchSouthern",
            "Heard Island and McDonald Islands": "HeardIsland",
            "Holy See (Vatican City State)": "Vatican",
            "Iran, Islamic Republic of": "Iran",
            "Korea, Democratic People's Republic of": "North Korea",
            "Korea, Republic of": "South Korea",
            "Lao People's Democratic Republic": "Laos",
            "Micronesia, Federated States of": "Micronesia",
            "Moldova, Republic of": "Moldova",
            "Palestine, State of": "Palestine",
            "Saint Helena, Ascension and Tristan da Cunha": "SaintHelena",
            "Saint Martin (French part)": "SaintMartin",
            "Sint Maarten (Dutch part)": "SintMaarten",
            "South Georgia and the South Sandwich Islands": "SouthGeorgia",
            "Syrian Arab Republic": "Syria",
            "Taiwan, Province of China": "Taiwan",
            "Tanzania, United Republic of": "Tanzania",
            "United States Minor Outlying Islands": "USMinorOutlyingIslands",
            "Venezuela, Bolivarian Republic of": "Venezuela",
            "Virgin Islands, British": "British Virgin Islands",
            "Virgin Islands, U.S.": "US Virgin Islands",
        };

        if (shortNames[enumCountryKey]) {
            enumCountryKey = shortNames[enumCountryKey];
        }

        enumCountryKey = transliterate.transliterate(enumCountryKey);
        enumCountryKey = enumCountryKey.replace(",", "");
        enumCountryKey = enumCountryKey.replace(".", "");
        enumCountryKey = enumCountryKey.replace("'", "");
        enumCountryKey = enumCountryKey.replace("-", "");
        enumCountryKey = enumCountryKey.replace("*", "");
        enumCountryKey = enumCountryKey.replace(/( ?)\(.*\)( ?)/, "");
        enumCountryKey = enumCountryKey.replace(/( ?)\[.*\]( ?)/, "");
        enumCountryKey = enumCountryKey
            .split(" ")
            .filter((s) => s.length > 0)
            .map((str) => `${str[0].toUpperCase()}${str.slice(1)}`)
            .join("");

        result.name.key = `Name${enumCountryKey}`;
        result.key = enumCountryKey;

        return result;
    });

    // Sort by alpha-2 code for stable, predictable output order
    codes.sort((a, b) => a.a2.value.localeCompare(b.a2.value));

    // --- Country templates ---

    // Pre-sort variants for each output file
    const byName = [...codes].sort((a, b) => a.name.value.localeCompare(b.name.value));
    const byA2 = codes; // already sorted by alpha-2
    const byA3 = [...codes].sort((a, b) => a.a3.value.localeCompare(b.a3.value));

    const genHeader = "// Code generated by country/.generator; DO NOT EDIT.\n\n";

    const countriesTemplate = genHeader + `package name

import "github.com/mikekonan/go-types/v2/country"

const (
${byName.map((code) => `\t${code.key} = country.Name("${code.name.value}")`).join("\n")}
)
`;

    const alpha2Template = genHeader + `package alpha2

import "github.com/mikekonan/go-types/v2/country"

const (
${byA2.map((code) => `\t${code.a2.value} = country.Alpha2Code("${code.a2.value}")`).join("\n")}
)
`;

    const alpha3Template = genHeader + `package alpha3

import "github.com/mikekonan/go-types/v2/country"

const (
${byA3.map((code) => `\t${code.a3.value} = country.Alpha3Code("${code.a3.value}")`).join("\n")}
)
`;

    const entitiesTemplate = genHeader + `package country

var (
${codes.map(
    (code) => `\t${code.key} = Country{\n\t\tname:   \"${code.name.value}\",\n\t\talpha2: \"${code.a2.value}\",\n\t\talpha3: \"${code.a3.value}\",\n\t}`
).join("\n")}
)
`;

    const countryByCountryTemplate = genHeader + `package country

var countryByName = map[string]Country{
${byName.map((code) => `\t\"${code.name.value}\": ${code.key}`).join(",\n")},
}

var countryByAlpha2 = map[string]Country{
${byA2.map((code) => `\t\"${code.a2.value}\": ${code.key}`).join(",\n")},
}

var countryByAlpha3 = map[string]Country{
${byA3.map((code) => `\t\"${code.a3.value}\": ${code.key}`).join(",\n")},
}
`;

    const countrySpec = {
        openapi: "3.0.0",
        components: {
            schemas: {
                CountryName: {
                    example: "Austria",
                    type: "string",
                    format: "iso3166-country",
                    enum: byName.map((code) => code.name.value),
                    "x-go-type": "github.com/mikekonan/go-types/v2/country.Name",
                },
                CountryAlpha2: {
                    example: "AS",
                    type: "string",
                    format: "iso3166-alpha-2",
                    minLength: 2,
                    maxLength: 2,
                    enum: byA2.map((code) => code.a2.value),
                    "x-go-type": "github.com/mikekonan/go-types/v2/country.Alpha2Code",
                },
                CountryAlpha3: {
                    example: "USA",
                    type: "string",
                    format: "iso3166-alpha-3",
                    minLength: 3,
                    maxLength: 3,
                    enum: byA3.map((code) => code.a3.value),
                    "x-go-type": "github.com/mikekonan/go-types/v2/country.Alpha3Code",
                }
            },
        },
    };

    // --- Write country files ---
    log("Writing country files...");

    const countryFiles = [
        { path: "../name/name_gen.go", content: countriesTemplate },
        { path: "../alpha2/alpha_2_gen.go", content: alpha2Template },
        { path: "../alpha3/alpha_3_gen.go", content: alpha3Template },
        { path: "../entities_gen.go", content: entitiesTemplate },
        { path: "../country_mapping_gen.go", content: countryByCountryTemplate },
        { path: "../swagger_gen.yaml", content: yaml.stringify(countrySpec) },
    ];

    for (const file of countryFiles) {
        const fullPath = path.resolve(__dirname, file.path);
        fs.writeFileSync(fullPath, file.content, { encoding: "utf8", flag: "w" });
        log("  Wrote " + file.path + " (" + fs.statSync(fullPath).size + " bytes)");
    }

    log("Country generation complete: " + codes.length + " countries, " + countryFiles.length + " files");
}

function generateSubdivision(entries) {
    log("Processing " + entries.length + " subdivisions...");

    let subdivisions = entries.map((entry) => {
        const code = entry.code;
        const countryCode = code.split("-")[0];
        const varName = code.replace("-", "");
        const constName = code.replace("-", "_");

        return {
            code: code,
            name: entry.name,
            type: entry.type || "",
            countryCode: countryCode,
            varName: varName,
            constName: constName,
        };
    });

    subdivisions.sort((a, b) => a.code.localeCompare(b.code));
    log("Sorted " + subdivisions.length + " subdivisions by code");

    // Collision detection for generated identifiers
    const varNames = new Map();
    const constNames = new Map();
    for (const sub of subdivisions) {
        if (varNames.has(sub.varName)) {
            throw new Error(`varName collision: '${sub.varName}' from '${sub.code}' and '${varNames.get(sub.varName)}'`);
        }
        if (constNames.has(sub.constName)) {
            throw new Error(`constName collision: '${sub.constName}' from '${sub.code}' and '${constNames.get(sub.constName)}'`);
        }
        varNames.set(sub.varName, sub.code);
        constNames.set(sub.constName, sub.code);
    }
    log("No identifier collisions detected");

    // Group by country
    const byCountry = {};
    for (const sub of subdivisions) {
        if (!byCountry[sub.countryCode]) {
            byCountry[sub.countryCode] = [];
        }
        byCountry[sub.countryCode].push(sub);
    }
    const countryCodes = Object.keys(byCountry).sort();
    log("Countries with subdivisions: " + countryCodes.length);
    log("Top countries: " +
        countryCodes
            .map((cc) => cc + "=" + byCountry[cc].length)
            .sort((a, b) => parseInt(b.split("=")[1]) - parseInt(a.split("=")[1]))
            .slice(0, 10)
            .join(", "));

    // --- Subdivision templates ---

    const subGenHeader = "// Code generated by country/.generator; DO NOT EDIT.\n\n";

    const subEntitiesTemplate = subGenHeader + `package subdivision

var (
${subdivisions.map(
    (sub) => `\t${sub.varName} = Subdivision{\n\t\tname:        "${sub.name.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}",\n\t\tcode:        "${sub.code}",\n\t\tcountryCode: "${sub.countryCode}",\n\t\tcategory:    "${sub.type}",\n\t}`
).join("\n")}
)
`;

    const uniqueNames = [...new Set(subdivisions.map((s) => s.name))].sort();
    const uniqueCategories = [...new Set(subdivisions.map((s) => s.type).filter((t) => t.length > 0))].sort();

    const subMappingTemplate = subGenHeader + `package subdivision

var subdivisionByCode = map[string]Subdivision{
${subdivisions.map((sub) => `\t"${sub.code}": ${sub.varName}`).join(",\n")},
}

var subdivisionsByCountry = map[string][]Subdivision{
${countryCodes.map((cc) =>
    `\t"${cc}": {\n${byCountry[cc].map((sub) => `\t\t${sub.varName}`).join(",\n")},\n\t}`
).join(",\n")},
}

var subdivisionNames = map[string]struct{}{
${uniqueNames.map((n) => `\t"${n.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}": {}`).join(",\n")},
}

var subdivisionCategories = map[string]struct{}{
${uniqueCategories.map((c) => `\t"${c}": {}`).join(",\n")},
}
`;

    const subCodeTemplate = subGenHeader + `package code

import "github.com/mikekonan/go-types/v2/country/subdivision"

const (
${subdivisions.map((sub) => `\t${sub.constName} = subdivision.Code("${sub.code}")`).join("\n")}
)
`;

    const subSpec = {
        openapi: "3.0.0",
        components: {
            schemas: {
                SubdivisionCode: {
                    example: "US-CA",
                    type: "string",
                    format: "iso3166-2",
                    enum: [...new Set(subdivisions.map((sub) => sub.code))],
                    "x-go-type": "github.com/mikekonan/go-types/v2/country/subdivision.Code",
                },
            },
        },
    };

    // --- Write subdivision files ---
    const subDir = path.resolve(__dirname, "../subdivision");
    const subCodeDir = path.join(subDir, "code");

    if (!fs.existsSync(subCodeDir)) {
        fs.mkdirSync(subCodeDir, { recursive: true });
    }

    log("Writing subdivision files...");

    const subFiles = [
        { path: "subdivision/entities_gen.go", content: subEntitiesTemplate },
        { path: "subdivision/subdivision_mapping_gen.go", content: subMappingTemplate },
        { path: "subdivision/code/code_gen.go", content: subCodeTemplate },
        { path: "subdivision/swagger_gen.yaml", content: yaml.stringify(subSpec) },
    ];

    for (const file of subFiles) {
        const fullPath = path.resolve(__dirname, "..", file.path);
        fs.writeFileSync(fullPath, file.content, { encoding: "utf8", flag: "w" });
        log("  Wrote " + file.path + " (" + fs.statSync(fullPath).size + " bytes)");
    }

    log("Subdivision generation complete: " + subdivisions.length + " subdivisions across " + countryCodes.length + " countries, " + subFiles.length + " files");
}

// ============================================================
// Main: fetch both sources from Debian iso-codes, generate all
// ============================================================
log("Fetching ISO 3166-1 from " + COUNTRY_SOURCE_URL);
log("Fetching ISO 3166-2 from " + SUBDIVISION_SOURCE_URL);

Promise.all([
    fetchJSON(COUNTRY_SOURCE_URL),
    fetchJSON(SUBDIVISION_SOURCE_URL),
])
    .then(([countryData, subdivisionData]) => {
        generateCountry(countryData["3166-1"]);
        generateSubdivision(subdivisionData["3166-2"]);
        log("Done!");
    })
    .catch((err) => {
        process.stderr.write("[gen] ERROR: " + err.message + "\n");
        process.exit(1);
    });
